/* eslint-disable react/no-unknown-property */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: DatSketch (https://sketchfab.com/DatSketch)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/imac-2021-304cb06ffb554883a7a642b2b56754c1
Title: iMac 2021
*/

import { useRef, useEffect } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import { a } from '@react-spring/three'

import Imacscene from '../Home_logo/imac.glb';

const Imac = ({isRotating, setisRotating, setCurrentStage, ...props}) => {
  const imacRef = useRef();
  
  const { gl, viewport} = useThree();
  const { nodes, materials } = useGLTF(Imacscene);

  const lastX = useRef(0);
  const rotationSpeed = useRef(0);
  const dampingFactor = 0.95;

  const handlepointerDown = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setisRotating(true);

    const clientX = e.touches ? e.touches[0].clientX : e.clientX;

    lastX.current = clientX;
  }

  const handlepointerUp = (e) => {
    e.stopPropagation();
    e.preventDefault();
    setisRotating(false);

  }

  const handlepointerMove = (e) => {
    e.stopPropagation();
    e.preventDefault();

    if(isRotating) {
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const delta = (clientX - lastX.current)/viewport.width;
      imacRef.current.rotation.y += delta * 0.01 * Math.PI;
      lastX.current = clientX;
      rotationSpeed.current =delta * 0.01 * Math.PI;
    }

  }

  const handleKeyDown = (e) => {
    if(e.key === 'ArrowLeft') {
      if(!isRotating) setisRotating(true);
      imacRef.current.rotation.y -= 0.01 * Math.PI;
    } else if(e.key === 'ArrowRight') {
      if(!isRotating) setisRotating(true);
      imacRef.current.rotation.y += 0.01 * Math.PI;
    }
  }

  const handleKeyUp = (e) => {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
      setisRotating(false);
    }
  }


useFrame(() => {
  if (!isRotating) {
    rotationSpeed.current *= dampingFactor;

    if (Math.abs(rotationSpeed.current) < 0.001) {
      rotationSpeed.current = 0;
    }

    imacRef.current.rotation.y += rotationSpeed.current;
  } else {
    const rotation = imacRef.current.rotation.y;

    const normalizedRotation =
      ((rotation % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);

    // Set the current stage based on the island's orientation
    switch (true) {
      case normalizedRotation >= 0 && normalizedRotation <= 2 * Math.PI:
        setCurrentStage(1);
        break;
      default:
        setCurrentStage(null);
    }
  }
});



  useEffect(() => {
    const canvas = gl.domElement;
    canvas.addEventListener('pointerup', handlepointerUp);
    canvas.addEventListener('pointermove', handlepointerMove);
    canvas.addEventListener('pointerdown', handlepointerDown);
    document.addEventListener('keydown', handleKeyDown);
    document.addEventListener('keyup', handleKeyUp);

    return () => {
      canvas.removeEventListener('pointerup', handlepointerUp);
      canvas.removeEventListener('pointermove', handlepointerMove);
      canvas.removeEventListener('pointerdown', handlepointerDown);
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('keyup', handleKeyUp);
    }
  }, [gl, handlepointerDown, handlepointerMove, handlepointerUp])

  return (
    <a.group ref={imacRef}{...props}>
      <group rotation={[-Math.PI / 2, 0, 0]} scale={100}>
        <mesh
          geometry={nodes.Stand_LightBlue_0.geometry}
          material={materials.LightBlue}
        />
        <group position={[0.032, 0, 0.387]}>
          <mesh
            geometry={nodes.Rotate_Metal_0.geometry}
            material={materials.Metal}
          />
          <mesh  
            geometry={nodes.Rotate_Metal2_0.geometry}
            material={materials.Metal2}
          />
          <group position={[-0.03, 0, -0.387]}>
            <mesh 
              geometry={nodes.Screen_DarkBlue_0.geometry}
              material={materials.DarkBlue}
            />
            <mesh
              geometry={nodes.Screen_LightBlue_0.geometry}
              material={materials.LightBlue}
            />
            <mesh
              geometry={nodes.Screen_Black_0.geometry}
              material={materials.Black}
            />
            <mesh
              geometry={nodes.Screen_White_0.geometry}
              material={materials.White}
            />
            <mesh
              geometry={nodes.Screen_Screen_0.geometry}
              material={materials.Screen}
            />
            <mesh
              geometry={nodes.Screen_Chrome_0.geometry}
              material={materials.Chrome}
            />
            <mesh
              geometry={nodes.Screen_CamBlack_0.geometry}
              material={materials["Cam.Black"]}
            />
            <mesh
              geometry={nodes.Screen_Lens_0.geometry}
              material={materials.Lens}
            />
            <mesh
              geometry={nodes.Screen_Glass_0.geometry}
              material={materials.Glass}
            />
            <mesh
              geometry={nodes.Screen_Black001_0.geometry}
              material={materials["Black.001"]}
            />
            <mesh
              geometry={nodes.Screen_Yellow_0.geometry}
              material={materials.Yellow}
            />
          </group>
        </group>
      </group>
    </a.group>
  );
}


export default Imac;